# ğŸš€ **LeetCode Problem Solutions â€“ Two Pointer & HashMap Mastery**

Complete guide with crystal-clear explanations, intuitions, and step-by-step breakdowns for interview preparation.

---

## ğŸ“‹ **Table of Contents**

1. [Two Sum](#1ï¸âƒ£-leetcode-1--two-sum)
2. [Two Sum II â€“ Sorted Array](#2ï¸âƒ£-leetcode-167--two-sum-ii-sorted-array)
3. [Merge Sorted Array](#3ï¸âƒ£-leetcode-88--merge-sorted-array)
4. [Count Pairs Whose Sum < Target](#4ï¸âƒ£-leetcode-2824--count-pairs-whose-sum--target)
5. [3Sum](#5ï¸âƒ£-leetcode-15--3sum)

---

## 1ï¸âƒ£ **LeetCode 1 â€“ Two Sum**

### ğŸ”— **Problem Link**
[LeetCode 1 - Two Sum](https://leetcode.com/problems/two-sum/)

### ğŸ’¡ **Intuition / Approach**

**Problem:** Given an **unsorted array**, find two numbers that add up to the target.

**Key Insight:** 
- For each number `x`, we need to find if `(target - x)` exists in the array
- Instead of checking the entire array repeatedly (O(nÂ²)), we can use a **HashMap** to instantly check if the required partner exists

**Think of it like this:**
```
nums = [2, 7, 11, 15], target = 9

At index 0: current = 2
  â†’ Need: 9 - 2 = 7
  â†’ Is 7 in map? NO
  â†’ Store: {2: 0}

At index 1: current = 7
  â†’ Need: 9 - 7 = 2
  â†’ Is 2 in map? YES! âœ…
  â†’ Return: [0, 1]
```

### â“ **Why Use HashMap?**

| Approach | Time Complexity | Why? |
|----------|----------------|------|
| **Brute Force** (nested loops) | O(nÂ²) | Check every pair - slow! |
| **HashMap** | O(n) | Instant lookup - one pass only! |

**HashMap gives us:**
- âœ… O(1) lookup time
- âœ… Single pass through array
- âœ… Store number â†’ index mapping

### â±ï¸ **Complexity Analysis**

- **Time Complexity:** O(n) â€“ we traverse array once
- **Space Complexity:** O(n) â€“ HashMap stores at most n elements

### ğŸ“ **Code with Detailed Comments**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // HashMap to store: number â†’ its index
        unordered_map<int, int> mp;
        
        for(int i = 0; i < nums.size(); i++) {
            // Calculate what number we need to reach target
            int diff = target - nums[i];
            
            // Check if required number already exists in map
            if(mp.find(diff) != mp.end()) {
                // Found! Return both indices
                return {mp[diff], i};
            }
            
            // Store current number with its index for future lookups
            mp[nums[i]] = i;
        }
        
        return {}; // No solution found
    }
};
```

### ğŸ”„ **Step-by-Step Execution**

**Example:** `nums = [3, 2, 4], target = 6`

| Step | i | nums[i] | diff | HashMap Before | Action | Result |
|------|---|---------|------|----------------|--------|--------|
| 1 | 0 | 3 | 6-3=3 | {} | 3 not in map | mp = {3:0} |
| 2 | 1 | 2 | 6-2=4 | {3:0} | 4 not in map | mp = {3:0, 2:1} |
| 3 | 2 | 4 | 6-4=2 | {3:0, 2:1} | 2 found! âœ… | return [1, 2] |

### ğŸ—ºï¸ **Mind Map / Key Points**

```
Two Sum (Unsorted Array)
â”‚
â”œâ”€ Problem: Find 2 numbers = target
â”œâ”€ Key Insight: Use HashMap for O(1) lookup
â”œâ”€ Algorithm:
â”‚  â”œâ”€ Calculate: diff = target - current
â”‚  â”œâ”€ Check: Is diff in map?
â”‚  â”‚  â”œâ”€ YES â†’ Return indices
â”‚  â”‚  â””â”€ NO â†’ Store current in map
â”‚  â””â”€ Continue
â””â”€ Complexity: O(n) time, O(n) space
```

**Remember:** 
- HashMap = Fast Partner Finder ğŸ”
- diff = target - current
- Store as you go, check before storing

---

## 2ï¸âƒ£ **LeetCode 167 â€“ Two Sum II (Sorted Array)**

### ğŸ”— **Problem Link**
[LeetCode 167 - Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

### ğŸ’¡ **Intuition / Approach**

**Problem:** Given a **sorted array**, find two numbers that add up to the target.

**Key Insight:** 
- Array is **sorted** â†’ we can use **Two Pointers** technique
- Start pointer at beginning, end pointer at end
- Move pointers based on sum comparison

**Visual Understanding:**
```
numbers = [2, 7, 11, 15], target = 9

Start: [2, 7, 11, 15]
        â†‘           â†‘
      start        end
      
Sum = 2 + 15 = 17 > 9 (too big!)
â†’ Move end left

Next:  [2, 7, 11, 15]
        â†‘       â†‘
      start    end
      
Sum = 2 + 11 = 13 > 9 (still too big!)
â†’ Move end left

Next:  [2, 7, 11, 15]
        â†‘   â†‘
      start end
      
Sum = 2 + 7 = 9 âœ… Found!
```

### â“ **Why Use Two Pointers?**

| Approach | Time | Space | Why Better? |
|----------|------|-------|-------------|
| HashMap | O(n) | O(n) | Works but uses extra space |
| **Two Pointers** | **O(n)** | **O(1)** | âœ… No extra space + sorted advantage! |

**Two Pointers Logic:**
- Sum **too small** â†’ increase sum â†’ move **start** right â†’
- Sum **too big** â†’ decrease sum â†’ move **end** left â†
- Sum **equals target** â†’ Found! âœ…

### â±ï¸ **Complexity Analysis**

- **Time Complexity:** O(n) â€“ single pass with two pointers
- **Space Complexity:** O(1) â€“ no extra data structures

### ğŸ“ **Code with Detailed Comments**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int start = 0;                    // Left pointer
        int end = numbers.size() - 1;     // Right pointer
        
        while(start < end) {
            int sum = numbers[start] + numbers[end];
            
            if(sum == target) {
                // Found! Return 1-based indices
                return {start + 1, end + 1};
            }
            else if(sum < target) {
                // Sum too small â†’ need bigger number
                // Move start right to increase sum
                start++;
            }
            else {
                // Sum too big â†’ need smaller number
                // Move end left to decrease sum
                end--;
            }
        }
        
        return {}; // No solution
    }
};
```

### ğŸ”„ **Step-by-Step Execution**

**Example:** `numbers = [2, 3, 4], target = 6`

| Step | start | end | numbers[start] | numbers[end] | sum | Action |
|------|-------|-----|----------------|--------------|-----|--------|
| 1 | 0 | 2 | 2 | 4 | 6 | sum == target âœ… |
| Result | | | | | | return [1, 3] |

**Example 2:** `numbers = [1, 2, 3, 4, 6], target = 6`

| Step | start | end | sum | Comparison | Action |
|------|-------|-----|-----|------------|--------|
| 1 | 0 | 4 | 1+6=7 | 7 > 6 | end-- |
| 2 | 0 | 3 | 1+4=5 | 5 < 6 | start++ |
| 3 | 1 | 3 | 2+4=6 | 6 == 6 âœ… | return [2, 4] |

### ğŸ—ºï¸ **Mind Map / Key Points**

```
Two Sum II (Sorted Array)
â”‚
â”œâ”€ Key: Array is SORTED
â”œâ”€ Technique: Two Pointers
â”œâ”€ Pointer Movement:
â”‚  â”œâ”€ sum < target â†’ start++ (increase sum)
â”‚  â”œâ”€ sum > target â†’ end-- (decrease sum)
â”‚  â””â”€ sum == target â†’ Found!
â”œâ”€ Why Better?: O(1) space vs HashMap O(n)
â””â”€ Return: 1-based indices
```

**Remember:**
- Sorted array = Two Pointers opportunity ğŸ¯
- Compare sum, move accordingly
- O(1) space advantage!

---

## 3ï¸âƒ£ **LeetCode 88 â€“ Merge Sorted Array**

### ğŸ”— **Problem Link**
[LeetCode 88 - Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)

### ğŸ’¡ **Intuition / Approach**

**Problem:** Merge two sorted arrays into `nums1` **in-place** (nums1 has extra space).

**Key Insight:** 
- Merging from **start** â†’ would overwrite nums1 elements âŒ
- Merging from **end** â†’ empty space available âœ…
- Place largest elements first at the end

**Visual Understanding:**
```
nums1 = [1, 2, 3, 0, 0, 0], m = 3
nums2 = [2, 5, 6], n = 3

Step 1: Compare from end
[1, 2, 3, 0, 0, 0]
       â†‘        â†‘
       i        k
[2, 5, 6]
       â†‘
       j

Compare: 3 vs 6 â†’ 6 is bigger
Place 6 at position k

Step 2:
[1, 2, 3, 0, 0, 6]
       â†‘     â†‘
       i     k
[2, 5, 6]
    â†‘
    j

Compare: 3 vs 5 â†’ 5 is bigger
Place 5 at position k

... continue until done
```

### â“ **Why Merge from End?**

| Approach | Issue | Solution |
|----------|-------|----------|
| Start â†’ End | Overwrites nums1 elements | âŒ Need extra space |
| **End â†’ Start** | Empty space at end of nums1 | âœ… No overwriting! |

**Advantages:**
- âœ… No extra array needed
- âœ… Truly in-place
- âœ… Uses empty space smartly

### â±ï¸ **Complexity Analysis**

- **Time Complexity:** O(m + n) â€“ single pass through both arrays
- **Space Complexity:** O(1) â€“ no extra space, merge in-place

### ğŸ“ **Code with Detailed Comments**

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // Three pointers: i (nums1), j (nums2), k (merged position)
        int i = m - 1;        // Last element of nums1's valid part
        int j = n - 1;        // Last element of nums2
        int k = m + n - 1;    // Last position in nums1 (total array)
        
        // Merge from end to start
        while(i >= 0 && j >= 0) {
            if(nums1[i] > nums2[j]) {
                // nums1's element is bigger
                nums1[k--] = nums1[i--];
            }
            else {
                // nums2's element is bigger or equal
                nums1[k--] = nums2[j--];
            }
        }
        
        // If nums2 has remaining elements, copy them
        // (If nums1 has remaining, they're already in place)
        while(j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
};
```

### ğŸ”„ **Step-by-Step Execution**

**Example:** `nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3`

| Step | i | j | k | nums1[i] | nums2[j] | Compare | Action | nums1 State |
|------|---|---|---|----------|----------|---------|--------|-------------|
| Start | 2 | 2 | 5 | 3 | 6 | 3 < 6 | Place nums2[j] | [1,2,3,0,0,6] |
| 1 | 2 | 1 | 4 | 3 | 5 | 3 < 5 | Place nums2[j] | [1,2,3,0,5,6] |
| 2 | 2 | 0 | 3 | 3 | 2 | 3 > 2 | Place nums1[i] | [1,2,3,3,5,6] |
| 3 | 1 | 0 | 2 | 2 | 2 | 2 == 2 | Place nums2[j] | [1,2,2,3,5,6] |
| 4 | 1 | -1 | 1 | - | - | j done | Exit while | [1,2,2,3,5,6] |
| Final | | | | | | | | **[1,2,2,3,5,6]** âœ… |

### ğŸ—ºï¸ **Mind Map / Key Points**

```
Merge Sorted Array
â”‚
â”œâ”€ Challenge: Merge in-place without extra space
â”œâ”€ Key Insight: Merge from END â†’ avoid overwriting
â”œâ”€ Three Pointers:
â”‚  â”œâ”€ i â†’ last valid element in nums1
â”‚  â”œâ”€ j â†’ last element in nums2
â”‚  â””â”€ k â†’ current merge position
â”œâ”€ Algorithm:
â”‚  â”œâ”€ Compare nums1[i] vs nums2[j]
â”‚  â”œâ”€ Place LARGER at nums1[k]
â”‚  â”œâ”€ Move corresponding pointer
â”‚  â””â”€ Copy remaining nums2 if any
â””â”€ Complexity: O(m+n) time, O(1) space
```

**Remember:**
- Start from END, not beginning! ğŸ”š
- Three pointers: i, j, k
- Pick the BIGGER element
- Copy remaining nums2 if needed

---

## 4ï¸âƒ£ **LeetCode 2824 â€“ Count Pairs Whose Sum < Target**

### ğŸ”— **Problem Link**
[LeetCode 2824 - Count Pairs Whose Sum < Target](https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/)

### ğŸ’¡ **Intuition / Approach**

**Problem:** Count all pairs `(i, j)` where `i < j` and `nums[i] + nums[j] < target`.

**Key Insight:** 
- Brute force: Check all pairs â†’ O(nÂ²) with nested loops
- **Optimization:** Sort + Two Pointers â†’ count multiple pairs at once!
- If `nums[start] + nums[end] < target`, then ALL elements between start and end form valid pairs with start

**Visual Understanding:**
```
nums = [1, 2, 3, 4], target = 5

After sorting: [1, 2, 3, 4]

Step 1: start=0, end=3
[1, 2, 3, 4]
 â†‘        â†‘
start    end

sum = 1 + 4 = 5 (NOT < 5)
â†’ end--

Step 2: start=0, end=2
[1, 2, 3, 4]
 â†‘     â†‘
start end

sum = 1 + 3 = 4 < 5 âœ…
Valid pairs: (1,2), (1,3) â†’ count = 2
â†’ start++

Step 3: start=1, end=2
[1, 2, 3, 4]
    â†‘  â†‘
  start end

sum = 2 + 3 = 5 (NOT < 5)
â†’ end--

Done! Total count = 2
```

### â“ **Why Sort First?**

| Approach | Time | Why? |
|----------|------|------|
| Brute Force (nested loops) | O(nÂ²) | Check every pair one by one |
| **Sort + Two Pointers** | **O(n log n)** | âœ… Count multiple pairs at once! |

**Magic of Sorted Array:**
When `nums[start] + nums[end] < target`:
- `nums[start] + nums[start+1] < target` (smaller number)
- `nums[start] + nums[start+2] < target` (even smaller)
- ... ALL elements from start+1 to end work!
- **Count += (end - start)** pairs in one step! ğŸ¯

### â±ï¸ **Complexity Analysis**

- **Time Complexity:** O(n log n) â€“ sorting takes O(n log n), two pointers scan is O(n)
- **Space Complexity:** O(1) â€“ only using pointers

### ğŸ“ **Code with Detailed Comments**

```cpp
class Solution {
public:
    int countPairs(vector<int>& nums, int target) {
        // Sort to enable two-pointer technique
        sort(nums.begin(), nums.end());
        
        int start = 0;
        int end = nums.size() - 1;
        int count = 0;
        
        while(start < end) {
            int sum = nums[start] + nums[end];
            
            if(sum < target) {
                // KEY INSIGHT: If nums[start] + nums[end] < target,
                // then nums[start] + ALL elements from (start+1 to end)
                // will also be < target (because array is sorted)
                count += (end - start);
                start++;  // Move to next element
            }
            else {
                // Sum >= target, need smaller sum
                end--;    // Move end pointer left
            }
        }
        
        return count;
    }
};
```

### ğŸ”„ **Step-by-Step Execution**

**Example:** `nums = [-1, 1, 2, 3, 1], target = 2`

**After sorting:** `nums = [-1, 1, 1, 2, 3]`

| Step | start | end | nums[start] | nums[end] | sum | Comparison | Action | Count Added | Total Count |
|------|-------|-----|-------------|-----------|-----|------------|--------|-------------|-------------|
| 1 | 0 | 4 | -1 | 3 | 2 | 2 == 2 | end-- | 0 | 0 |
| 2 | 0 | 3 | -1 | 2 | 1 | 1 < 2 âœ… | start++ | 3 | 3 |
| 3 | 1 | 3 | 1 | 2 | 3 | 3 > 2 | end-- | 0 | 3 |
| 4 | 1 | 2 | 1 | 1 | 2 | 2 == 2 | end-- | 0 | 3 |
| Done | 1 | 1 | - | - | - | start==end | Stop | - | **3** |

**Valid pairs:** (-1,1), (-1,1), (-1,2) = **3 pairs** âœ…

### ğŸ—ºï¸ **Mind Map / Key Points**

```
Count Pairs (Sum < Target)
â”‚
â”œâ”€ Step 1: SORT the array
â”œâ”€ Step 2: Two Pointers (start, end)
â”œâ”€ Logic:
â”‚  â”œâ”€ sum < target:
â”‚  â”‚  â”œâ”€ ALL pairs from start to end are valid
â”‚  â”‚  â”œâ”€ count += (end - start)
â”‚  â”‚  â””â”€ start++
â”‚  â””â”€ sum >= target:
â”‚     â””â”€ end-- (reduce sum)
â”œâ”€ Why Sort?: Enables counting multiple pairs at once
â””â”€ Complexity: O(n log n) time, O(1) space
```

**Remember:**
- Sort first! ğŸ“Š
- sum < target â†’ count += (end - start)
- One pointer move can count MULTIPLE pairs
- Sorted array = efficiency boost

---

## 5ï¸âƒ£ **LeetCode 15 â€“ 3Sum**

### ğŸ”— **Problem Link**
[LeetCode 15 - 3Sum](https://leetcode.com/problems/3sum/)

### ğŸ’¡ **Intuition / Approach**

**Problem:** Find all **unique triplets** `[a, b, c]` where `a + b + c = 0`.

**Key Insight:** 
- Convert 3Sum problem â†’ 2Sum problem!
- Fix one element â†’ find two elements that sum to `-fixed_element`
- Sort array to easily skip duplicates

**Breakdown:**
1. **Sort** the array
2. **Fix** first element (loop with `i`)
3. Use **Two Pointers** (left, right) for remaining two elements
4. **Skip duplicates** to ensure unique triplets

**Visual Understanding:**
```
nums = [-1, 0, 1, 2, -1, -4]

After sorting: [-4, -1, -1, 0, 1, 2]

Fix i=1 (nums[i]=-1):
Need: 0 - (-1) = 1

[-4, -1, -1, 0, 1, 2]
      â†‘   â†‘        â†‘
      i   l        r

sum = -1 + (-1) + 2 = 0 âœ…
Found: [-1, -1, 2]

Skip duplicates, continue...
```

### â“ **Why Sort + Two Pointers?**

| Approach | Time | Issues |
|----------|------|--------|
| Three nested loops | O(nÂ³) | Too slow + hard to avoid duplicates |
| **Sort + Fix one + 2 Pointers** | **O(nÂ²)** | âœ… Efficient + easy duplicate handling |

**Advantages:**
- âœ… Reduces from O(nÂ³) to O(nÂ²)
- âœ… Sorted array helps skip duplicates easily
- âœ… Two pointer technique for inner elements

### â±ï¸ **Complexity Analysis**

- **Time Complexity:** O(nÂ²) â€“ O(n log n) for sort + O(nÂ²) for loop with two pointers
- **Space Complexity:** O(1) â€“ excluding output array (sorting is typically O(log n) for space)

### ğŸ“ **Code with Detailed Comments**

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        
        // Step 1: Sort to enable two-pointer and skip duplicates
        sort(nums.begin(), nums.end());
        
        // Step 2: Fix first element
        for(int i = 0; i < nums.size(); i++) {
            // Skip duplicate first elements
            if(i > 0 && nums[i] == nums[i-1]) 
                continue;
            
            // Step 3: Two pointers for remaining two elements
            int l = i + 1;              // Left pointer
            int r = nums.size() - 1;    // Right pointer
            
            while(l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                
                if(sum == 0) {
                    // Found a valid triplet!
                    ans.push_back({nums[i], nums[l], nums[r]});
                    
                    // Skip duplicate left elements
                    while(l < r && nums[l] == nums[l+1]) 
                        l++;
                    
                    // Skip duplicate right elements
                    while(l < r && nums[r] == nums[r-1]) 
                        r--;
                    
                    // Move both pointers
                    l++;
                    r--;
                }
                else if(sum < 0) {
                    // Sum too small, need bigger number
                    l++;
                }
                else {
                    // Sum too big, need smaller number
                    r--;
                }
            }
        }
        
        return ans;
    }
};
```

### ğŸ”„ **Step-by-Step Execution**

**Example:** `nums = [-1, 0, 1, 2, -1, -4]`

**After sorting:** `[-4, -1, -1, 0, 1, 2]`

| i | nums[i] | l | r | sum | Action | Result |
|---|---------|---|---|-----|--------|--------|
| 0 | -4 | 1 | 5 | -4+-1+2=-3 | sum<0, l++ | - |
| 0 | -4 | 2 | 5 | -4+-1+2=-3 | sum<0, l++ | - |
| 0 | -4 | 3 | 5 | -4+0+2=-2 | sum<0, l++ | - |
| 0 | -4 | 4 | 5 | -4+1+2=-1 | sum<0, l++ | - |
| 0 | -4 | 5 | 5 | l==r | Next i | - |
| **1** | **-1** | 2 | 5 | -1+-1+2=0 âœ… | Found! | **[-1,-1,2]** |
| 1 | -1 | 3 | 4 | -1+0+1=0 âœ… | Found! | **[-1,0,1]** |
| 2 | -1 | - | - | Skip (duplicate) | continue | - |
| 3+ | - | - | - | No valid triplets | - | - |

**Final Answer:** `[[-1,-1,2], [-1,0,1]]` âœ…

### ğŸ—ºï¸ **Mind Map / Key Points**

```
3Sum Problem
â”‚
â”œâ”€ Goal: Find unique triplets with sum = 0
â”œâ”€ Strategy: Fix one + Two Pointers for rest
â”‚
â”œâ”€ Algorithm:
â”‚  â”œâ”€ Step 1: SORT array
â”‚  â”œâ”€ Step 2: Loop with i (fix first element)
â”‚  â”‚   â””â”€ Skip duplicates: if nums[i]==nums[i-1]
â”‚  â”œâ”€ Step 3: Two Pointers (l, r)
â”‚  â”‚   â”œâ”€ sum == 0: Add to result, skip duplicates, move both
â”‚  â”‚   â”œâ”€ sum < 0: l++ (need bigger)
â”‚  â”‚   â””â”€ sum > 0: r-- (need smaller)
â”‚  â””â”€ Return all unique triplets
â”‚
â”œâ”€ Duplicate Handling:
â”‚  â”œâ”€ Skip duplicate i values
â”‚  â”œâ”€ Skip duplicate l values
â”‚  â””â”€ Skip duplicate r values
â”‚
â””â”€ Complexity: O(nÂ²) time, O(1) space
```

**Remember:**
- Sort first! ğŸ“Š
- Fix `i`, then 2Sum problem for rest
- Skip duplicates at ALL levels (i, l, r)
- sum logic: <0 â†’ l++, >0 â†’ r--, ==0 â†’ found!

---

## ğŸ¯ **Final Comparison Table**

| Problem | Technique | Key Insight | Time | Space |
|---------|-----------|-------------|------|-------|
| **Two Sum** | HashMap | Unsorted â†’ instant lookup | O(n) | O(n) |
| **Two Sum II** | Two Pointers | Sorted â†’ move based on sum | O(n) | O(1) |
| **Merge Sorted** | Three Pointers | Merge from END | O(m+n) | O(1) |
| **Count Pairs** | Sort + Two Pointers | count += (end-start) | O(n log n) | O(1) |
| **3Sum** | Sort + Fix + Two Pointers | Fix one, 2Sum for rest | O(nÂ²) | O(1) |

---

## ğŸ§  **Quick Revision Checklist**

**When to use HashMap:**
- âœ… Unsorted array
- âœ… Need O(1) lookup
- âœ… Finding pairs/complements

**When to use Two Pointers:**
- âœ… Sorted array (or sort first)
- âœ… Need O(1) space
- âœ… Finding pairs/triplets with sum conditions

**Golden Rules:**
1. **Sorted array** â†’ Think Two Pointers first
2. **Unsorted + need pairs** â†’ Think HashMap
3. **Merge operations** â†’ Work from END
4. **Avoid duplicates** â†’ Sort + skip same values
5. **3Sum/4Sum** â†’ Fix element(s) + reduce to 2Sum
