 four LeetCode problems (125, 344, 680, 977) with:

* **Problem link**
* **Intuition / Approach**
* **Why using this approach**
* **Time & Space Complexity**
* **Step-by-step explanation**
* **Mind map / key points**




# üìò **LeetCode Problem Solutions ‚Äì Two Pointer Series**

This repository contains professional explanations and solutions for the following **classic two-pointer problems**:

| Problem                         | Link                                                                              |
| ------------------------------- | ------------------------------------------------------------------------          |
| 125 ‚Äì Valid Palindrome          | [LeetCode 125]https://leetcode.com/problems/valid-palindrome/description/         |
| 344 ‚Äì Reverse String            | [LeetCode 344](https://leetcode.com/problems/reverse-string/description/)                     |
| 680 ‚Äì Valid Palindrome II       | [LeetCode 680](https://leetcode.com/problems/valid-palindrome-ii/description)                |
| 977 ‚Äì Squares of a Sorted Array | [LeetCode 977](https://leetcode.com/problems/squares-of-a-sorted-array/description)          |

---

## 1Ô∏è‚É£ **LeetCode 125 ‚Äì Valid Palindrome**

**Problem:** Check if a string is a palindrome **ignoring case and non-alphanumeric characters**.

**Intuition:**

* Palindrome ‚Üí string reads same forward and backward
* Use **two pointers** (start, end)
* Skip non-alphanumeric characters
* Convert to lowercase to handle case-insensitive comparison
* Compare characters at both pointers ‚Üí move inward

**Why Two Pointers:**

* Efficient ‚Üí only one pass
* No extra memory needed

**Approach / Steps:**

1. Initialize `start=0`, `end=n-1`
2. Skip characters if not alphanumeric
3. Compare lowercase characters
4. Mismatch ‚Üí return false
5. Loop ends ‚Üí return true

**Code:**

```cpp
string s = "A man, a plan, a canal: Panama";
int start = 0, end = s.size() - 1;

while (start < end) {
    if (!isalnum(s[start])) { start++; continue; }
    if (!isalnum(s[end])) { end--; continue; }
    if (tolower(s[start]) != tolower(s[end])) {
        cout << "false";
        return 0;
    }
    start++;
    end--;
}
cout << "true";
```

**Time Complexity:** O(n) ‚Üí scan each character once
**Space Complexity:** O(1) ‚Üí in-place comparison

---

## 2Ô∏è‚É£ **LeetCode 344 ‚Äì Reverse String**

**Problem:** Reverse a character array **in-place** with O(1) extra memory

**Intuition:**

* Swap first and last element, move pointers inward until they meet
* Use **two pointers** (`start` and `end`)

**Why Two Pointers:**

* In-place swap ‚Üí no extra array required
* Single pass ‚Üí O(n)

**Approach / Steps:**

1. Initialize `start=0`, `end=n-1`
2. Swap `s[start]` and `s[end]`
3. Move `start++`, `end--`
4. Repeat until start >= end

**Code:**

```cpp
vector<char> s = {'h','e','l','l','o'};
int start = 0, end = s.size() - 1;

while (start < end) {
    swap(s[start], s[end]);
    start++;
    end--;
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## 3Ô∏è‚É£ **LeetCode 680 ‚Äì Valid Palindrome II**

**Problem:** Determine if a string can become a palindrome **by deleting at most one character**

**Intuition:**

* Two pointers check for mismatch
* If mismatch ‚Üí two options: remove left or remove right
* If either option results in palindrome ‚Üí true

**Why This Approach:**

* Efficient ‚Üí O(n)
* Only one pass
* Handles ‚Äúat most one deletion‚Äù constraint

**Steps:**

1. Initialize `start=0`, `end=n-1`
2. While `start < end`

   * If match ‚Üí move inward
   * If mismatch ‚Üí check two options: `start+1,end` OR `start,end-1`
3. If any option returns true ‚Üí palindrome possible

**Code:**

```cpp
bool check(vector<char>& s, int start, int end) {
    while (start < end) {
        if (s[start] != s[end]) return false;
        start++; end--;
    }
    return true;
}

int main() {
    vector<char> s = {'a','b','c','a'};
    int start=0,end=s.size()-1;

    while (start<end) {
        if (s[start]==s[end]) { start++; end--; }
        else {
            cout << (check(s,start+1,end) || check(s,start,end-1));
            return 0;
        }
    }
    cout << "true";
}
```

**Time Complexity:** O(n) ‚Üí single pass + one extra check
**Space Complexity:** O(1)

---

## 4Ô∏è‚É£ **LeetCode 977 ‚Äì Squares of a Sorted Array**

**Problem:** Given a **sorted array**, return **squares of each number** in **sorted order**

**Intuition:**

* Negative numbers when squared may be largest
* Use **two pointers** at start and end
* Compare squares ‚Üí fill result array from end to start

**Why This Approach:**

* Single pass ‚Üí O(n)
* Efficient for sorted array

**Steps:**

1. Initialize `start=0`, `end=n-1`, `k=n-1`
2. Compare `nums[start]^2` vs `nums[end]^2`
3. Place larger at `ans[k]`, k--
4. Move pointers inward
5. Repeat until start > end

**Code:**

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        int start=0, end=n-1, k=n-1;
        vector<int> ans(n);

        while (start <= end) {
            int leftSq = nums[start]*nums[start];
            int rightSq = nums[end]*nums[end];
            if (leftSq > rightSq) {
                ans[k] = leftSq;
                start++;
            } else {
                ans[k] = rightSq;
                end--;
            }
            k--;
        }
        return ans;
    }
};
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)

---

## üîπ **Mind Map / Quick Revision (All Problems)**

```
125 ‚Äì Valid Palindrome
  Two pointer ‚Üí skip non-alpha ‚Üí lowercase ‚Üí compare

344 ‚Äì Reverse String
  Two pointer ‚Üí swap start/end ‚Üí in-place

680 ‚Äì Valid Palindrome II
  Two pointer ‚Üí mismatch ‚Üí delete left or right ‚Üí check palindrome

977 ‚Äì Squares of Sorted Array
  Two pointer ‚Üí compare squares ‚Üí fill from end
```

---

‚úÖ **Why Two Pointer Approach Works for All:**

* Efficient ‚Üí O(n) scan
* Simple logic for start/end comparison
* Handles in-place operations
* Minimal extra memory

--